;*****************************************************************************/
;*  Communication with an EEPROM (e.g. 2465) via I2C bus                     */
;*  The I2C module of the MSP430F169 is used to communicate with the EEPROM. */
;*  The "Byte Write", "Current Address Read", "Random Read", and             */
;*  "Acknowledge Polling" commands or the EEPROM are realized.               */
;*                                                                           */
;*  developed with IAR Embedded Workbench V2.20                              */
;*                                                                           */
;*  Texas Instruments Deutschland GmbH                                       */
;*  Christian Hernitscheck                                                   */
;*  August 2004                                                              */
;*---------------------------------------------------------------------------*/
;*  updates                                                                  */
;*     Jan 2005:                                                             */
;*         - updated initialization sequence                                 */
;*****************************************************************************/
;
; THIS PROGRAM IS PROVIDED "AS IS". TI MAKES NO WARRANTIES OR
; REPRESENTATIONS, EITHER EXPRESS, IMPLIED OR STATUTORY,
; INCLUDING ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS
; FOR A PARTICULAR PURPOSE, LACK OF VIRUSES, ACCURACY OR
; COMPLETENESS OF RESPONSES, RESULTS AND LACK OF NEGLIGENCE.
; TI DISCLAIMS ANY WARRANTY OF TITLE, QUIET ENJOYMENT, QUIET
; POSSESSION, AND NON-INFRINGEMENT OF ANY THIRD PARTY
; INTELLECTUAL PROPERTY RIGHTS WITH REGARD TO THE PROGRAM OR
; YOUR USE OF THE PROGRAM.
;
; IN NO EVENT SHALL TI BE LIABLE FOR ANY SPECIAL, INCIDENTAL,
; CONSEQUENTIAL OR INDIRECT DAMAGES, HOWEVER CAUSED, ON ANY
; THEORY OF LIABILITY AND WHETHER OR NOT TI HAS BEEN ADVISED
; OF THE POSSIBILITY OF SUCH DAMAGES, ARISING IN ANY WAY OUT
; OF THIS AGREEMENT, THE PROGRAM, OR YOUR USE OF THE PROGRAM.
; EXCLUDED DAMAGES INCLUDE, BUT ARE NOT LIMITED TO, COST OF
; REMOVAL OR REINSTALLATION, COMPUTER TIME, LABOR COSTS, LOSS
; OF GOODWILL, LOSS OF PROFITS, LOSS OF SAVINGS, OR LOSS OF
; USE OR INTERRUPTION OF BUSINESS. IN NO EVENT WILL TI'S
; AGGREGATE LIABILITY UNDER THIS AGREEMENT OR ARISING OUT OF
; YOUR USE OF THE PROGRAM EXCEED FIVE HUNDRED DOLLARS
; (U.S.$500).
;
; Unless otherwise stated, the Program written and copyrighted
; by Texas Instruments is distributed as "freeware".  You may,
; only under TI's copyright in the Program, use and modify the
; Program without any charge or restriction.  You may
; distribute to third parties, provided that you transfer a
; copy of this license to the third party and the third party
; agrees to these terms by its first use of the Program. You
; must reproduce the copyright notice and any other legend of
; ownership on each copy or partial copy, of the Program.
;
; You acknowledge and agree that the Program contains
; copyrighted material, trade secrets and other TI proprietary
; information and is protected by copyright laws,
; international copyright treaties, and trade secret laws, as
; well as other intellectual property laws.  To protect TI's
; rights in the Program, you agree not to decompile, reverse
; engineer, disassemble or otherwise translate any object code
; versions of the Program to a human-readable form.  You agree
; that in no event will you alter, remove or destroy any
; copyright notice included in the Program.  TI reserves all
; rights not specifically granted under this license. Except
; as specifically provided herein, nothing in this agreement
; shall be construed as conferring by implication, estoppel,
; or otherwise, upon you, any license or other right under any
; TI patents, copyrights or trade secrets.
;
; You may not use the Program in non-TI devices.
;
;******************************************************************************
#include "msp430x16x.h"

SlaveAddress   equ   50h

            public InitI2C
            public EEPROM_ByteWrite
            public EEPROM_RandomRead
            public EEPROM_CurrentAddressRead
            public EEPROM_AckPolling

            RSEG   DATA16_Z
PtrTransmit DS     2
I2CBuffer   DS     4

            RSEG CODE
InitI2C                 ;----- Initialization of the I2C Module -----
            MOV.b  #0Ah,&P3SEL          ; select module function for the used I2C pins
            BIC.b  #0Ah,&P3DIR

;*** Recommended initialisation steps of I2C module as shown in User Guide:
            BIS.b  #I2C+SYNC,&U0CTL     ; (1) Select I2C mode with SWRST=1
            BIC.b  #I2CEN,&U0CTL        ; (2) Disable the I2C module
                                        ; (3) Re-configure the I2C module with I2CEN=0 :
                                        ;     U0CTL default settings:
                                        ;     7-bit addressing, no DMA, no feedback
            MOV.b  #I2CTRX+I2CSSEL_2,&I2CTCTL
                                        ;     byte mode, repeat mode, clock source=SMCLK,
                                        ;     transmit mode
            MOV    #SlaveAddress,&I2CSA ;     define Slave Address
                                        ;     In this case the Slave Address defines the
                                        ;     control byte that is sent to the EEPROM.
            MOV    #01A5h,&I2COA        ;     own address.
            MOV.b  #00h,&I2CPSC         ;     I2C clock = clock source/1
            MOV.b  #03h,&I2CSCLH        ;     SCL high period = 5*I2C clock
            MOV.b  #03h,&I2CSCLL        ;     SCL low period  = 5*I2C clock
            BIS.b  #I2CEN,&U0CTL        ; (4) set I2CEN via software
            RET


I2CWriteInit            ; Initialization of the I2C Module for Write operation
            BIS.b  #MST,&U0CTL       ; define Master Mode
            BIS.b  #I2CTRX,&I2CTCTL  ; I2CTRX=1 => Transmit Mode (R/W bit = 0)
            BIC.b  #TXRDYIFG,&I2CIFG
            MOV.b  #TXRDYIE,&I2CIE   ; enable Transmit ready interrupt
            RET


I2CReadInit             ; Initialization of the I2C Module for Read operation
            BIC.b  #I2CTRX,&I2CTCTL  ; I2CTRX=0 => Receive Mode (R/W bit = 1)
            MOV.b  #RXRDYIE,&I2CIE   ; enable Receive ready interrupt
            RET


EEPROM_ByteWrite
; Description:
;   Byte Write Operation. The communication via the I2C bus with an EEPROM
;   (2465) is realized. A data byte is written into a user defined address.
;   Parameter:   Address => R12
;                Data    => R14
;   Scratch Reg: R15
wait1
            BIT.b  #I2CBUSY,&I2CDCTL    ; wait until I2C module has finished all operations
            JC     wait1
            MOV    R12,R15              ; calculate high byte and ...
            SWPB   R15
            MOV.b  R15,I2CBuffer+2
            MOV.b  R12,I2CBuffer+1      ; ... low byte of address
            MOV.b  R14,I2CBuffer+0
            MOV    #2,PtrTransmit       ; set I2CBuffer Pointer
            CALL   #I2CWriteInit
            MOV.b  #03h,&I2CNDAT        ; 1 control byte + 3 bytes should be transmitted
            BIS.b  #I2CSTT+I2CSTP,&I2CTCTL ; start and stop condition generation
                                           ;      => I2C communication is started
            RET


EEPROM_CurrentAddressRead
; Description:
;   Current Address Read Operation. Data is read from the EEPROM. The current
;   address from the EEPROM is used.
;   return Parameter:  Data => R12
wait2
            BIT.b  #I2CBUSY,&I2CDCTL ; wait until I2C module has finished all operations
            JC     wait2
            CALL   #I2CReadInit
            BIS.b  #MST,&U0CTL       ; define Master Mode
            MOV.b  #01h,&I2CNDAT     ; 1 byte should be received
            BIC.b  #ARDYIFG,&I2CIFG  ; clear Access ready interrupt flag
            BIS.b  #I2CSTT+I2CSTP,&I2CTCTL  ; start communiction
wait3
            BIT.b  #ARDYIFG,&I2CIFG  ; wait untill transmission is finished
            JNC    wait3
            MOV.b  &I2CBuffer+0,R12
            RET


EEPROM_RandomRead
; Description:
;   Random Read Operation. Data is read from the EEPROM. The EEPROM
;   address is defined with the parameter Address.
;   Parameter:  Address => R12
;   Return Paramter:  Data => R12
;   Scratch Reg: R15
wait4
            BIT.b  #I2CBUSY,&I2CDCTL  ; wait until I2C module has finished all operations
            JC     wait4
            MOV    R12,R15            ; calculate high byte and ...
            SWPB   R15
            MOV.b  R15,I2CBuffer+1
            MOV.b  R12,I2CBuffer+0    ; ... low byte of address
            MOV    #01h,PtrTransmit   ; set I2CBuffer Pointer
            CALL   #I2CWriteInit
            MOV.b  #02h,&I2CNDAT      ; 1 control byte + 2 bytes should be transmitted
            BIC.b  #ARDYIFG,&I2CIFG   ; clear Access ready interrupt flag
            BIS.b  #I2CSTT,&I2CTCTL   ; start condition generation
                            ;      => I2C communication is started
wait5
            BIT.b  #ARDYIFG,&I2CIFG  ; wait untill transmission is finished
            JNC    wait5
            CALL   #I2CReadInit
            MOV.b  #01h,&I2CNDAT     ; 1 byte should be received

            BIC.b  #ARDYIFG,&I2CIFG  ; clear Access ready interrupt flag
            BIS.b  #I2CSTT+I2CSTP,&I2CTCTL ; start receiving and finally generate
                                           ;                  re-start and stop condition
wait6
            BIT.b  #ARDYIFG,&I2CIFG  ; wait untill transmission is finished
            JNC    wait6
            MOV    I2CBuffer+0,R12
            RET


EEPROM_AckPolling
; Description:
;   Acknowledge Polling. The EEPROM will not acknowledge if a write cycle is
;   in progress. It can be used to determine when a write cycle is completed.
wait7
            BIT.b  #I2CBUSY,&I2CDCTL  ; wait until I2C module has finished all operations
            JC     wait7
            BIC.b  #I2CEN,&U0CTL      ; clear I2CEN bit => necessary to re-configure I2C module
            BIS.b  #I2CRM,&I2CTCTL    ; transmission is software controlled
            BIS.b  #I2CEN,&U0CTL      ; enable I2C module
wait8
            MOV.b  #00h,&I2CIFG       ; clear I2C interrupt flags
            BIS.b  #MST,&U0CTL        ; define Master Mode
            BIS.b  #I2CTRX,&I2CTCTL   ; I2CTRX=1 => Transmit Mode (R/W bit = 0)
            BIS.b  #I2CSTT,&I2CTCTL   ; start condition is generated
wait9
            BIT.b  #I2CSTT,&I2CTCTL   ; wait till I2CSTT bit was cleared
            JC     wait9
            BIS.b  #I2CSTP,&I2CTCTL   ; stop condition is generated after slave address was sent
                            ;      => I2C communication is started
wait10
            BIT.b  #I2CBUSY,&I2CDCTL  ; wait till stop bit is reset
            JC     wait10
            BIT.b  #NACKIFG,&I2CIFG
            JC     wait8
            BIC.b  #I2CEN,&U0CTL      ; clear I2CEN bit => necessary to re-configure I2C module
            BIC.b  #I2CRM,&I2CTCTL    ; transmission is by the I2C module
            BIS.b  #I2CEN,&U0CTL      ; enable I2C module
            RET


ISR_I2C
            ADD    &I2CIV,PC
            RETI
            JMP    ISR_ALIFG
            JMP    ISR_NACKIFG
            JMP    ISR_OAIFG
            JMP    ISR_ARDYIFG
            JMP    ISR_RXRDYIFG
            JMP    ISR_TXRDYIFG
            JMP    ISR_GCIFG
            JMP    ISR_STTIFG

ISR_ALIFG     ; I2C interrupt vector: Arbitration lost (ALIFG)
            RETI
ISR_NACKIFG   ; I2C interrupt vector: No acknowledge (NACKIFG)
            RETI
ISR_OAIFG     ; I2C interrupt vector: Own address (OAIFG)
            RETI
ISR_ARDYIFG   ; I2C interrupt vector: Access ready (ARDYIFG)
            RETI
ISR_RXRDYIFG  ; I2C interrupt vector: Receive ready (RXRDYIFG)
            MOV.b  &I2CDRB,I2CBuffer+0  ; store received data in buffer
            RETI
ISR_TXRDYIFG  ; I2C interrupt vector: Transmit ready (TXRDYIFG)
            PUSH   R6
            MOV    PtrTransmit,R6
            MOV.b  I2CBuffer(R6),&I2CDRB
            DEC    PtrTransmit
            JN     ISR_end1
            POP    R6
            RETI
ISR_end1
            BIC.b  #TXRDYIE,&I2CIE   ; disable interrupts
            POP    R6
            RETI
ISR_GCIFG     ; I2C interrupt vector: General call (GCIFG)
            RETI
ISR_STTIFG    ; I2C interrupt vector: Start condition (STTIFG)
            RETI

            COMMON  INTVEC
            ORG     USART0TX_VECTOR
            DW      ISR_I2C

            end
